---
layout: post
title: 理解补码
---

计算机中用补码表示二进制，要想彻底理解补码，必须先理解补码下的一些数学概念。

### 模运算
模运算（Modular Arithmetic）的核心是“**周期循环**”。例如：
- $x \mod 16$ 表示将 $x$ 映射到 $0 \sim 15$ 的范围内。
- 如果结果超过 15，则通过减去 16 回到范围内；如果是负数，则通过加上 16 回到范围内。

例如：
- $17 \mod 16 = 1$（超过范围时减去 16）
- $-5 \mod 16 = 11$（负数时加上 16）

### 同余

两个整数 a，b，若它们除以整数 m 所得的余数相等，则称 a，b 对于模 m 同余，记作 
$$
a \equiv b \pmod m
$$
读作 a 与 b 关于模 m 同余

### 补数

补数（complement）是对于给定的进位制，相加后能使自然数 a 的位数增加 1 的最小的数。
在数学和计算机科学中，补数是一种编码技术，使得计算正数和负数的加法可以使用相同的机制。 整数的常见补码方案有两种： 假设对于基数为r长度为n的整数范围，某个负数-y：

- 基数补数(radix complement)：$r^n-y$。
- 减一基数补数(dimished radix complement) $r^n-1-y$。$r^n-1$是一个每位的值都是r-1，共n位的数，所以减一基数补数比较好计算。

在十进制系统中，基数补数成为‘十补数’，减一基数补数成为‘九补数’；类似的，二进制系统中，分别成为‘二补数’和‘一补数’；其他进制以此类推。


### 补码

补码（**two's  complement**），正数和0的补码就是该数字本身再补上最高比特0。负数的补码则是将其绝对值按位取反再加1。定义
$$
\text{补码}(-x) = (2^n) - x
$$

- **模运算等价性**：补码的表示等价于将负数映射到模$2^n$下的正数。例如，$-1 \equiv 15 \mod 16$，因此`1111`既可以表示无符号数15，也可以表示有符号数$-1$。

---

### 加减法的自动模运算
- **溢出处理**：当补码加减运算超出范围时，高位溢出被丢弃，结果自动取模$2^n$。例如：
  - 在8位系统中，$127 + 1 = -128$（即`01111111 + 00000001 = 10000000`），这等价于$128 \mod 256 = -128$。
  - 在4位系统中，$7 + 1 = -8$（即`0111 + 0001 = 1000`），等价于$8 \mod 16 = -8$。
- **硬件简化**：计算机无需区分有符号和无符号加法，统一的加法器即可完成运算，依赖模运算自动处理符号。

|二进制数|无符号比特|有符号比特|反码|补码|
| :----: | :--: |:---: | :--: |:---: |
|0000|	0	|0	|0	|0|
|0001|	1	|1	|1	|1|
|0010|	2	|2	|2	|2|
|0011|	3	|3	|3	|3|
|0100|	4	|4	|4	|4|
|0101|	5	|5	|5	|5|
|0110|	6	|6	|6	|6|
|0111|	7	|7	|7	|7|
|1000|	8	|-0	|-7	|-8|
|1001|	9	|-1	|-6	|-7|
|1010|	10	|-2	|-5	|-6|
|1011|	11	|-3	|-4	|-5|
|1100|	12	|-4	|-3	|-4|
|1101|	13	|-5	|-2	|-3|
|1110|	14	|-6	|-1	|-2|
|1111|	15	|-7	|-0	|-1|

### 反码
补码并非唯一的负数表示方法。历史上还存在 **One's Complement**（反码），其定义为：
$$
\text{反码}(-x) = (2^n - 1) - x
$$
例如，在4位系统中，$-3$ 的反码为 $15 - 3 = 12$（二进制 `1100`）。

- **One's Complement**：以 $2^n - 1$（基数减1）为基准，仅对二进制位取反（如 `0011` → `1100`）。
- **Two's Complement**：以 $2^n$（基数本身）为基准，取反后加1（如 `0011` → `1100 + 1 = 1101`）。

**“Two's”** 与 **“One's”** 的命名差异，正是源于二者基准值的不同：
- **One's**：基准为 $2^n - 1$（基数减1）。
- **Two's**：基准为 $2^n$（基数本身）。